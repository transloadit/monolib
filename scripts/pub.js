const globby = require('globby')
const inflect = require('inflect')
const mkdirp = require('mkdirp')
const path = require('path')
const execa = require('execa')
const crypto = require('crypto')

const fsP = require('fs').promises
// const util = require('util')

const ROOT = `${__dirname}/..`
const SIMPLE = `${ROOT}/simple`

async function simpleToPackages () {
  console.log(`==> simpleToPackages`)
  const files = await globby([
    `${SIMPLE}/*.js`,
    `!${SIMPLE}/*.test.js`,
  ])

  for (const file of files) {
    const funcName = path.basename(file, '.js')
    const pkgName  = inflect.dasherize(inflect.underscore(funcName))
    const dirPath  = `${ROOT}/packages/${pkgName}`
    const pkgPath  = `${dirPath}/package.json`
    const entry    = `./index.js`

    console.log(`--> creating ${dirPath.replace(ROOT, '.')}`)
    await mkdirp(dirPath)

    const subfiles = await globby([`${SIMPLE}/${funcName}*.js`, `!${SIMPLE}/${funcName}*.test.js`])
    for (const subfile of subfiles) {
      const src = subfile
      const dst = `${dirPath}/index.js`

      console.log(`--> copying ${src.replace(ROOT, '.')} -> ${dst.replace(ROOT, '.')}`)
      const buf = `//\n// WARNING. DO NOT EDIT THIS FILE. EDIT IN ${src.replace(ROOT, '.')} INSTEAD\n//\n\n` + await fsP.readFile(src, 'utf-8')
      await fsP.writeFile(dst, buf, 'utf-8')
    }

    let nowPkg = {}
    try {
      nowPkg = JSON.parse(await fsP.readFile(`${pkgPath}`, 'utf-8'))
      // eslint-disable-next-line no-empty
    } catch (err) { console.error(err) }

    const pkg = {
      ...nowPkg,
      name      : `@transloadit/${pkgName}`,
      version   : '0.0.1',
      repository: {
        type     : `git`,
        url      : `git://github.com/transloadit/monolib.git`,
        directory: `packages/${pkgName}`,
      },
      publishConfig: {
        registry: `https://npm.pkg.github.com/`,
      },
      main: entry,
    }

    console.log(`--> writing ${pkgPath.replace(ROOT, '.')}`)
    await fsP.writeFile(`${pkgPath}`, JSON.stringify(pkg, null, '  '), 'utf-8')
  }
}

async function _pkgToHash (pkgPath) {
  const dirName = path.dirname(pkgPath)
  const pkg = JSON.parse(await fsP.readFile(`${pkgPath}`, 'utf-8'))
  const pkgFile = `${dirName}/${pkg.main}`
  const payload = await fsP.readFile(pkgFile, 'utf-8')

  if (!('main' in pkg)) {
    throw new Error(`There is no 'main' field in '${pkgPath.replace(ROOT, '.')}'`)
  }

  const pkgWithoutHashAndVersion = JSON.parse(JSON.stringify(pkg))
  delete pkgWithoutHashAndVersion.transloaditHash
  delete pkgWithoutHashAndVersion.version
  const transloaditHash = crypto.createHash('sha1').update(JSON.stringify([pkgWithoutHashAndVersion, payload])).digest('hex')
  return { pkg, pkgWithoutHashAndVersion, transloaditHash }
}

async function publishPackages () {
  console.log(`==> publishPackages`)
  const files = await globby([
    `${ROOT}/packages/*/package.json`,
  ])
  for (const file of files) {
    const dirName = path.dirname(file)
    const pkgPath = `${dirName}/package.json`

    const ret = await _pkgToHash(pkgPath)
    const transloaditHash = ret.transloaditHash
    const pkg = ret.pkg

    if (pkg.transloaditHash === transloaditHash) {
      console.log(`--> skip publishing ${dirName.replace(ROOT, '.')}`)
    } else {
      console.log(`--> publishing ${dirName.replace(ROOT, '.')} because ${pkg.transloaditHash} != ${transloaditHash}`)

      const cmd = `cd '${dirName}' && ((yarn && yarn version --patch && npm publish); cd -)`
      await execa('sh', ['-c', cmd], { stdio: 'inherit' })

      console.log(`--> writing ${pkgPath.replace(ROOT, '.')}`)
      const ret2 = await _pkgToHash(pkgPath)
      const pkg2 = ret2.pkg
      pkg2.transloaditHash = transloaditHash
      await fsP.writeFile(`${pkgPath}`, JSON.stringify(pkg2, null, '  '), 'utf-8')
    }
  }
}

async function main () {
  await simpleToPackages()
  await publishPackages()
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})
